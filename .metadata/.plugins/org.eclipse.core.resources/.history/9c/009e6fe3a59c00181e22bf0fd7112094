#include "globals.h"
#include "Can1.h"
#include "PWM1.h"
#include "PWM2.h"
#include "ADC0.h"
#include "SW1.h"
#include "SW2.h"
#include "lookup.h"

void loop();

const uint16_t Steer_X[5] = {0x2200, 0x7900, 0x7C00, 0x8000, 0xDA00};
const int16_t  Steer_Y[5] = {-100,   0,      0,      0,      100};

const uint16_t Torque_X[5] = {0x2C00, 0x7D00, 0x8000, 0x8300, 0xC600};
const int16_t  Torque_Y[5] = {-100,   0,      0,      0,      100};

const uint16_t Aux_X[5] = {0x3000, 0x7900, 0x7B00, 0x7D00, 0xCC00};
const int16_t  Aux_Y[5] = {-100,   0,      0,      0,      100};


uint16_t ADCs[6] = {0,0,0,0,0,0};	
uint8_t count = 0, CRC = 0;

typedef union CAN_msg_t
{
	uint8_t bytes[8];
	uint16_t words[4];
} CAN_msg_t;

static uint8_t CRC_calc(CAN_msg_t* msg);


void loop()
{
	CAN_msg_t data;

	uint8_t err;
	
	err = ADC0_GetValue16(ADCs);
	
	// pack the CAN packets
	if(0 == (ms % 5))
	{		
		//data.bytes[0] = 0;
		//data.bytes[1] = count++;
		data.bytes[2] = (int8_t)lookup_u16_s16(ADCs[5], Steer_X, Steer_Y, 5);
		data.bytes[3] = (int8_t)lookup_u16_s16(ADCs[4], Torque_X, Torque_Y, 5);
		data.bytes[4] = (uint8_t)(ADCs[0] >> 8);
		data.bytes[5] = (uint8_t)(ADCs[2] >> 8);
		data.bytes[6] = (int8_t)lookup_u16_s16(ADCs[3], Aux_X, Aux_Y, 5);
		data.bytes[7] = 0;
		if(SW1_GetVal()) { data.bytes[7] += 0x10; }
		if(SW2_GetVal()) { data.bytes[7] += 0x01; }

		if(ADCs[0] > 0x8000) {
			data.bytes[1] = count++;
			data.bytes[0] = CRC_calc(&data);
			
		} else if(ADCs[0] > 0x4000) {
			data.bytes[1] = count++;
			data.bytes[0] = 0;
		} else {
			data.bytes[1] = 0;
			data.bytes[0] = 0;
		}
						
		err = CAN1_SendFrame(0, 0x117, DATA_FRAME, 8, &data.bytes[0]);
		
		data.words[0] = ADCs[0];
		data.words[1] = ADCs[1];
		data.words[2] = ADCs[2];
		data.words[3] = ADCs[3];
		
		//err = CAN1_SendFrame(1, 0x200, DATA_FRAME, 8, &data.bytes[0]);
		
		data.words[0] = ADCs[4];
		data.words[1] = ADCs[5];
		if(SW1_GetVal()) { data.words[2] = 0xFFFF; } else { data.words[2] = 0; }
		if(SW2_GetVal()) { data.words[3] = 0xFFFF; } else { data.words[3] = 0; }
		
		//err = CAN1_SendFrame(2, 0x201, DATA_FRAME, 8, &data.bytes[0]);

	}
		
	
//	// unpack the CAN packet
//	if(CANRX_timestamp[0] != CANRX_timestamp_prev[0])
//	{
//		mV1 = (uint16_t)(CANRX_data[0][0] << 8);
//		mV1 += CANRX_data[0][1];
//		mV2 = (uint16_t)(CANRX_data[0][2] << 8);
//		mV2 += CANRX_data[0][3];
//		// = CANRX_data[0][4];
//		// = CANRX_data[0][5];
//		// = CANRX_data[0][6];
//		
//		CANRX_timestamp_prev[0] = CANRX_timestamp[0];
//	}
//
//	
//	// PWMs
//	if(0 == (ms % 10))
//	{
//		V1_duty = lookup_u16_u16(mV1, V1_X_AXIS, V1_Y_AXIS, 3);
//		V2_duty = lookup_u16_u16(mV2, V2_X_AXIS, V2_Y_AXIS, 3);
//
//		PWM1_SetRatio16(V1_duty);
//		PWM2_SetRatio16(V2_duty);		
//	}

}

const uint8_t crc8_data[256] =
{
	0x00,0x1d,0x3a,0x27,0x74,0x69,0x4e,0x53,0xe8,0xf5,0xd2,0xcf,0x9c,0x81,0xa6,0xbb,
	0xcd,0xd0,0xf7,0xea,0xb9,0xa4,0x83,0x9e,0x25,0x38,0x1f,0x02,0x51,0x4c,0x6b,0x76,
	0x87,0x9a,0xbd,0xa0,0xf3,0xee,0xc9,0xd4,0x6f,0x72,0x55,0x48,0x1b,0x06,0x21,0x3c,
	0x4a,0x57,0x70,0x6d,0x3e,0x23,0x04,0x19,0xa2,0xbf,0x98,0x85,0xd6,0xcb,0xec,0xf1,
	0x13,0x0e,0x29,0x34,0x67,0x7a,0x5d,0x40,0xfb,0xe6,0xc1,0xdc,0x8f,0x92,0xb5,0xa8,
	0xde,0xc3,0xe4,0xf9,0xaa,0xb7,0x90,0x8d,0x36,0x2b,0x0c,0x11,0x42,0x5f,0x78,0x65,
	0x94,0x89,0xae,0xb3,0xe0,0xfd,0xda,0xc7,0x7c,0x61,0x46,0x5b,0x08,0x15,0x32,0x2f,
	0x59,0x44,0x63,0x7e,0x2d,0x30,0x17,0x0a,0xb1,0xac,0x8b,0x96,0xc5,0xd8,0xff,0xe2,
	0x26,0x3b,0x1c,0x01,0x52,0x4f,0x68,0x75,0xce,0xd3,0xf4,0xe9,0xba,0xa7,0x80,0x9d,
	0xeb,0xf6,0xd1,0xcc,0x9f,0x82,0xa5,0xb8,0x03,0x1e,0x39,0x24,0x77,0x6a,0x4d,0x50,
	0xa1,0xbc,0x9b,0x86,0xd5,0xc8,0xef,0xf2,0x49,0x54,0x73,0x6e,0x3d,0x20,0x07,0x1a,
	0x6c,0x71,0x56,0x4b,0x18,0x05,0x22,0x3f,0x84,0x99,0xbe,0xa3,0xf0,0xed,0xca,0xd7,
	0x35,0x28,0x0f,0x12,0x41,0x5c,0x7b,0x66,0xdd,0xc0,0xe7,0xfa,0xa9,0xb4,0x93,0x8e,
	0xf8,0xe5,0xc2,0xdf,0x8c,0x91,0xb6,0xab,0x10,0x0d,0x2a,0x37,0x64,0x79,0x5e,0x43,
	0xb2,0xaf,0x88,0x95,0xc6,0xdb,0xfc,0xe1,0x5a,0x47,0x60,0x7d,0x2e,0x33,0x14,0x09,
	0x7f,0x62,0x45,0x58,0x0b,0x16,0x31,0x2c,0x97,0x8a,0xad,0xb0,0xe3,0xfe,0xd9,0xc4
};

static uint8_t CRC_calc(CAN_msg_t* msg) {
	uint8_t data = 0xFF;

	data = crc8_data[data ^ msg->bytes[1]];
	data = crc8_data[data ^ msg->bytes[2]];
	data = crc8_data[data ^ msg->bytes[3]];
	data = crc8_data[data ^ msg->bytes[4]];
	data = crc8_data[data ^ msg->bytes[5]];
	data = crc8_data[data ^ msg->bytes[6]];
	data = crc8_data[data ^ msg->bytes[7]];
	
	return(data);
}
